---
title: 2024TJUACM 3.18-3.31 第三—五周记录
tags:
  - 程序设计
  - C++
categories:
  - ICPC-CCPC
mathjax: true
abbrlink: a991f22d
date: 2024-03-28 10:45:45
---

本两周概要总结

比赛训练：$Codeforces\ Round\ 936,Atcoder\ Beginner\ Contest\ 346-348$

教学训练：线段树$SegmentTree$，树链剖分（重链）$HeavyDeconposition$，扫描线$ScanningLine$

<!--more-->

{% spoiler "提示1" %}



{% endspoiler %}

# RM-TR-1 SegmentTree

## [题目信息](https://www.luogu.com.cn/problem/P3372)

如题，已知一个数列，你需要进行下面两种操作：

1. 将某区间每一个数加上 $k$。
2. 求出某区间每一个数的和。

**输入格式**

第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。

第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：

1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。
2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。

**输出格式**

输出包含若干行整数，即为所有操作 2 的结果。

**数据范围**

对于 $30\%$ 的数据：$n \le 8$，$m \le 10$。  
对于 $70\%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。  
对于 $100\%$ 的数据：$1 \le n, m \le {10}^5$。

保证任意时刻数列中所有元素的绝对值之和 $\le {10}^{18}$。

## 题目教学

线段树基础模板题，维护区间加以及区间和。

首先明确，线段树结点维护的是***节点所代表区间的一个可递归下传以及递归合并后上传***的信息，实现以区间为单位修改来节约大面积查询时间的目的。

对于一套线段树而言，其需要维护两个数组：一个记录区间维护信息的树节点数组$tree[maxn<<2]$，一个记录区间修改进行修改传递的懒惰标记$lazy$_$tag[maxn<<2]$。

线段树核心的两个操作就是标记下传和迭代上传。对于一个区间$[l,r]$的完成修改，我们可以通过记录区间所对应的$lazy$_$tag$来表示对整个区间的修改并***立即更新***该区间树节点维护的信息。***懒惰标记不操作于当前节点的信息，它提供的是当前区间的下级子区间尚且没有进行更新的维护内容，当前节点的区间信息已经在记录懒惰标记的同时就修改完毕了。***等到某次涉及到子区间的访问时，我们再把懒惰标记上所记录的***所有的记录（强调所有的记录，区间和的应用体现在懒惰标记的加法上）***全部下传更新到目标节点以便统一数据版本。这样的操作实现了“按所需更新，不更新无所谓的节点”来大幅度压缩区间修改的时间。

同理，涉及一次标记下传就需要对应一次标记上传，通过子节点的当前更新信息来上传父节点以便统一***该区间所影响到的全部上级结点的全部信息。***

查询不需要进行标记上传更新，没有影响。

```
void push_down(long long p, int len)//必须是当前区间懒惰标记对子区间造成的影响修改，下传不修改当前区间
{
     if (len <= 1)
         return;
     tree[p << 1] += lazy_tag[p] * (len - len / 2); // 左侧偏多，是建树的时候决定的
     lazy_tag[p << 1] += lazy_tag[p];
     tree[p << 1 | 1] += lazy_tag[p] * (len / 2);
     lazy_tag[p << 1 | 1] += lazy_tag[p];
     lazy_tag[p] = 0;//传递后归零
     return;
}
```

```
void push_up(int x,int len)//递归下传后必须对应修改上传
{
	tree[p]=tree[p<<1]+tree[p<<1|1];//上传信息依据树节点维护信息决定
	return;
}
```

关于建树、修改和查询，如果结点区间不在范围内直接返回（0），节点区间完整的包含在目标区间内则直接返回对应信息，否则递归拆分处理。

```
void rangemodify_(int l, int r, T d, long long p, int cl, int cr)
{
     if (cl > cr || cl > r || cr < l)//不合法以及越界行为，把不准就画画区间。注意区间开闭问题
            return;
     if (cl >= l && cr <= r)
     {
         tree[p] += d * (cr - cl + 1);
         lazy_tag[p] += d;
         return;
     }
     push_down(p, cr - cl + 1);
     int mid = (cl + cr) >> 1;
     rangemodify_(l, r, d, p << 1, cl, mid);
     rangemodify_(l, r, d, p << 1 | 1, mid + 1, cr);//闭区间mid+1，开区间mid，维护离散区间信息。
    //像后文的涂色、扫描线区间连续的就要使用[l,r)形式区间维护连续信息
     push_up(p,cr-cl+1);
     return;
}
```

```
T query(int l, int r, long long p, int cl, int cr)
{
     if (cl > cr || cl > r || cr < l)
         return 0;
     if (cl >= l && cr <= r)
         return tree[p];
     push_down(p, cr - cl + 1);
     int mid = (cl + cr) >> 1;
     return query(l, r, p << 1, cl, mid) + query(l, r, p << 1 | 1, mid + 1, cr);
}
```

## AC代码

{% spoiler "Accepted，Tried 5 times" %}

```
#include <bits/stdc++.h>
using namespace std;
template <class T>
class SegmentTree_for_Sum
{
private:
    int n;
    vector<T> tree, lazy_tag;
    void build(T *a, long long p, int cl, int cr)
    {
        if (cl > cr)
            return;
        if (cl == cr)
            return void(tree[p] = a[cl]);
        int mid = (cl + cr) >> 1;
        build(a, p << 1, cl, mid);
        build(a, p << 1 | 1, mid + 1, cr);
        tree[p] = tree[p << 1] + tree[p << 1 | 1];
        return;
    }
    void push_down(long long p, int len)
    {
        if (len <= 1)
            return;
        tree[p << 1] += lazy_tag[p] * (len - len / 2); // 左侧偏多，是建树的时候决定的
        lazy_tag[p << 1] += lazy_tag[p];
        tree[p << 1 | 1] += lazy_tag[p] * (len / 2);
        lazy_tag[p << 1 | 1] += lazy_tag[p];
        lazy_tag[p] = 0;
        return;
    }
    void rangemodify_(int l, int r, T d, long long p, int cl, int cr)
    {
        if (cl > cr || r < cl || l > cr)
            return;
        if (cl >= l && cr <= r)
        {
            tree[p] += d * (cr - cl + 1);
            lazy_tag[p] += d;
            return;
        }
        push_down(p, cr - cl + 1);
        int mid = (cl + cr) >> 1;
        rangemodify_(l, r, d, p << 1, cl, mid);
        rangemodify_(l, r, d, p << 1 | 1, mid + 1, cr);
        tree[p] = tree[p << 1] + tree[p << 1 | 1];
        return;
    }
    T query(int l, int r, long long p, int cl, int cr)
    {
        if (cl > cr || r < cl || l > cr)
            return 0;
        if (cl >= l && cr <= r)
            return tree[p];
        push_down(p, cr - cl + 1);
        int mid = (cl + cr) >> 1;
        return query(l, r, p << 1, cl, mid) + query(l, r, p << 1 | 1, mid + 1, cr);
    }

public:
    SegmentTree_for_Sum(T *a, int n) : n(n)
    {
        tree = vector<T>(n << 2 + 1);
        lazy_tag = vector<T>(n << 2 + 1);
        build(a, 1, 1, n);
        return;
    }
    // 区间增加
    void rangemodify(int l, int r, T d)
    {
        return rangemodify_(l, r, d, 1, 1, n);
    }
    // 区间查询
    T rangequery(int l, int r)
    {
        return query(l, r, 1, 1, n);
    }
    ~SegmentTree_for_Sum()
    {
        tree.clear();
        lazy_tag.clear();
    }
};
#define int long long
int a[200001];
signed main()
{
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    SegmentTree_for_Sum<int> S(a, n);
    while (q--)
    {
        int op, x, y;
        cin >> op >> x >> y;
        if (op == 1)
        {
            int d;
            cin >> d;
            S.rangemodify(x, y, d);
        }
        else
        {
            cout << S.rangequery(x, y) << endl;
        }
    }
    system("pause");
    return 0;
}
```

{% endspoiler %}

# RM-TR-2 Atlantis

## [题目信息](http://poj.org/problem?id=1151)

给定多个矩形的左下角和右上角坐标，求这些矩形面积的并。

**输入格式**

输入包括多组数据。

对于每一组数据，第一行一个整数$n$，表示矩形个数。

接下来$n$行每行四个数字$x_1,y_1,x_2,y_2$，表示第$i$个矩形的左下角和右上角坐标。

输入若干组数据后，以$0$​结尾终止输入。

**输出格式**

对于第$i$组数据，输出如下内容：

```
Test case #(the number of the testcase,normally i)
Total explored area:(the answer of testcase i,exact to two digits to the right of the decimal point.)
```

**样例输入**

```
2
10 10 20 20
15 15 25 25.5
0
```

**样例输出**

```
Test case #1
Total explored area: 180.00
```

## 题目教学

扫描线是基于线段树的一个实现，其前置内容为线段树求线段的并。

先解决上述问题。

$case\  1:$

给定长度为$n$的一条直线，$q$次询问，按以下要求操作。

操作$1$：将$[l,r)$区间所表示的线段加入集合或删除集合。保证$l,r$均为整数。

操作$2$​：查询集合内线段所覆盖的总长度。



通过线段树维护区间$[l,r)$内当前所有的线段的总长度即可。

对于区间$[l,r)$，维护区间线段总和$sum$以及区间**线段覆盖层数**$num$​.

修改操作：

修改完整区间$[l,r)$的信息时，直接按要求对$[l,r).num$​修改（加$1$或减$1$).

修改不完整区间，线段树二分划分修改。

下传操作：

由于$num$充当了懒惰标记的部分性能，并且因为$num$​只表示当前线段重叠了几条，不计算子线段拼起来部分。

所以**num**不下传，没有$push$_$down$函数.

举个例子，现在集合里面有$[1,3)$和$[3,5)$两条线段，但是没有$[1,5)$的完整线段。两个已有线段倒是能拼成一个$[1,5)$的线段，但是这个不算完整线段。所以$[1,5).num=0$.

上传操作：

如果区间$[l,r).num>0$，表示区间有完整线段存在，直接更新区间$[l,r).sum=cr-cl$.

否则，区间$[l,r)$内所含的线段长度由两个子区间内所包含的线段长度相加得到。

查询操作：

直接返回$tree[1].sum$的值。

因为查询线段的并必定是查询区间$[1,n+1)$内线段的总长度。

然后就不用查询函数了，只考虑建树的复杂度$O(nlogn)$,查询是常数级别。

需要注意的一点事带开区间的线段树要开$8$倍大小。

$case\ 2$：

不保证$[l,r)$为整数。

离线下来后离散化，然后再按顺序加入、删除、查询。

~~（强制在线先打问号？）~~



扫描线就是在上述内容基础之上。

![img](https://oi-wiki.org/geometry/images/scanning.svg)

这个动图已经足够说明意思了。扫描线从低向上扫，每两次修改之间计算当前线段并扫过部分的面积。扫到底边添加线段，扫到顶边不添加线段。

需要注意的是涉及到离散化的操作，这里有个问题就是离散化的时候没必要离散化$y$​,否则常数会过于巨大。

离散化操作细节详见代码，这样操作后相当于变成了$ABC346G$.

## AC代码

{% spoiler "Accepted" %}

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
int cnum = 0;
vector<int> fx;
struct node
{
    double x, y, x2;
    int flag;
    bool operator<(const node &b) const
    {
        return (y < b.y);
    }
};
int n;
const int maxn = 2e5 + 1;
typedef struct treenode
{
    int num = 0;
    double sum = 0;
} treenode;
treenode *tree;
vector<node> rem;
vector<vector<pair<pair<int, int>, int>>> operate;
int xsize;
void init()
{
    tree = new treenode[maxn << 3];
    for (int i = 1; i <= n; i++)
    {
        double x_1, y_1, x_2, y_2;
        scanf("%Lf%Lf%Lf%Lf", &x_1, &y_1, &x_2, &y_2);
        rem.push_back({x_1, y_1, x_2, 1}), rem.push_back({x_1, y_2, x_2, -1});
        fx.push_back(x_1), fx.push_back(x_2);
    }
    sort(fx.begin(), fx.end());
    xsize = unique(fx.begin(), fx.end()) - fx.begin();
    sort(rem.begin(), rem.end());
}
void push_up(int p, int cl, int cr)
{
    if (tree[p].num)
    {
        tree[p].sum = fx[cr] - fx[cl];
        return;
    }
    tree[p].sum = tree[p << 1LL].sum + tree[p << 1LL | 1LL].sum;
    return;
}
void modify(int l, int r, int d, int p = 1, int cl = 0, int cr = xsize - 1)
{
    if (cr <= cl || r <= fx[cl] || fx[cr] <= l)
        return;
    if (l <= fx[cl] && fx[cr] <= r)
    {
        tree[p].num += d;
        push_up(p, cl, cr);
        return;
    }
    int mid = (cl + cr) >> 1;
    modify(l, r, d, p << 1, cl, mid);
    modify(l, r, d, p << 1 | 1, mid, cr);
    push_up(p, cl, cr);
    return;
}
void solve()
{
    init();
    double ans = 0;
    for (int i = 0; i < rem.size() - 1; i++)
    {
        modify(rem[i].x, rem[i].x2, rem[i].flag);
        ans += tree[1].sum * (rem[i + 1].y - rem[i].y);
    }
    printf("Test case #%d\nTotal explored area: %.2Lf\n\n", cnum, ans);
    // cout << ans << '\n';
}
signed main()
{
    while (scanf("%lld", &n) && n != 0)
    {
        cnum++;
        solve();
    }
    // system("pause");
    return 0;
}
```

{% endspoiler %}

# RM-TR-3 Minimize Sum of Distances

## [题目信息](https://atcoder.jp/contests/abc348/tasks/abc348_e)

给你一棵有 $N$ 个顶点的树。顶点的编号为 $1$ 至 $N$ ， $i$ -th 边连接顶点 $A_i$ 和 $B_i$ 。

给出一个长度为 $N$ 的正整数序列 $C = (C_1, C_2, \ldots ,C_N)$ 。设 $d(a, b)$ 是顶点 $a$ 和 $b$ 之间的边数，而 $x = 1, 2, \ldots, N$ 的边数为 $\displaystyle f(x) = \sum_{i=1}^{N} (C_i \times d(x, i))$ 。

求出 $\displaystyle \min_{1 \leq v \leq N} f(v)$ .

## 题目教学

不难想到随便找一个点将整棵树挂起来之后先算出来一个值，然后在节点之间$O(1)$的转移。

问题是如何实现$O(1)$的转移。

举个例子，你有以下情况的树存在(样例2）：

![Figure_1](D:\HexoBlog\SkyEyeController.github.io\source\_posts\2024TJUACM-3-18-3-31-第三——四周记录\Figure_1.png)

然后把结点$1$挂起进行了一次计算后，我想进行$O(1)$的转移到将结点$2$挂起时的结果。不难发现这一步操作要减去以节点$2$为根的子树的节点值总和$\sum C_i$以及加上剩余其他节点的节点值总和$sum-\sum C_i$​。

如何快速查询总和？显然将子树的结点全部编号成连续号就可以扔到前缀和或者树状数组里面解决了。

那么，**重链剖分($HeavyDecomposition$)** 就是这样的一种编号方式。

重链剖分可以将树上的任意一条路径划分成不超过$O(logn)$条连续的链，每条链上的点深度互不相同（即是自底向上的一条链，链上所有点的 $LCA$ 为链的一个端点)。以及最关键的，重链剖分还能保证划分出的每条链上的节点 $DFS$ 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。

**剖分实现过程**

给出一些定义：

定义 **重子节点** 表示其子节点中子树最大的子结点。如果有多个子树最大的子结点，取其一。如果没有子节点，就无重子节点。

定义 **轻子节点** 表示剩余的所有子结点。

从这个结点到重子节点的边为 **重边**。

到其他轻子节点的边为 **轻边**。

若干条首尾衔接的重边构成 **重链**。

把落单的结点也当作重链，那么整棵树就被剖分成若干条重链。

![HLD](https://oi-wiki.org/graph/images/hld.png)

很明显，这样进行划分后，树具有以下的性质：

1. **树上每个节点都属于且仅属于一条重链**。

2. 重链开头的结点不一定是重子节点（因为重边是对于每一个结点都有定义的）。

3. 所有的重链将整棵树 **完全剖分**。

4. 在剖分时 **重边优先遍历**，最后树的 DFS 序上，重链内的 DFS 序是连续的。按 DFN 排序后的序列即为剖分后的链。

5. 一颗子树内的 DFS 序是连续的。

6. 当我们向下经过一条 **轻边** 时，所在子树的大小至少会除以二。因此，对于树上的任意一条路径，把它拆分成从$LCA$分别向两边往下走，分别最多走$O(logn)$次，因此，树上的每条路径都可以被拆分成不超过$O(logn)$条重链。

**剖分实现方法**：

进行两次$DFS$.

第一次扫出来每个节点的父节点$father$、各节点子树大小$size$、各节点重儿子$hson$以及当前树深度$depth$。

```
int dfs1(int u, int dep)
{
    depth[u] = dep;
    Size[u] = 1;
    for (auto p : connects[u])
    {
        if (p == father[u])
            continue;
        father[p] = u;
        Size[u] += dfs1(p, dep + 1);
        if (Size[p] > Size[hson[u]])
            hson[u] = p;
    }
    return Size[u];
}
```

第二次扫出来每条链链顶$top$、各节点目标$dfn$序以及其反函数$rank$。初始化根节点$u=t$

```
void dfs2(int u, int t)
{
    top[u] = t;
    dfn[u] = ++tot;
    invdfn[tot] = u;
    if (hson[u])
    {
        dfs2(hson[u], t);
        for (auto p : connects[u])
            if (father[u] != p && hson[u] != p)
                dfs2(p, p);
    }
    return;
}
```

