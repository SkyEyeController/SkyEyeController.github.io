---
title: 22232程序设计实践·基础算法2
tags:
  - 程序设计
  - C++
  - 算法自学
categories:
  - 笔记
abbrlink: 2a94924b
date: 2023-03-06 09:57:46
mathjax: true
---

这是本系列的第二篇文章，旨在记录我学习C++历程中所有的感想和感悟。
***本片摘要：***
<!--more-->

# 2.

## 题目信息
***题目描述：***

***输入***

***输出***

***样例输入***

***样例输出***

***数据范围***

## 题目分析

# 2.1 最多水容器
## 题目信息
***题目描述：***
给定一个数组, 每个数值代表柱子的高度, 那么求出这些柱子最多可以装多少水. 水的体积由较短的长度乘以两个柱子的距离.

<img src="2-1.png" alt="2-1" style="zoom:80%;" />


上面的图的输入为 [1,8,6,2,5,4,8,3,7]. 蓝色区域最可以装水为49.
***输入***
第一行输入一个数字N表示容器个数。第二行输入N个使用空格间隔的证书，表示容器高度。
***输出***
输出一个数字表示最多装水量。
***样例输入***
```
9
1 8 6 2 5 4 8 3 7
```
***样例输出***
```
49
```
***数据范围***
$2 <= N <= 10$
## 题目分析
***方法一：暴力模拟***
直接$C_{n}^{2}$暴力选取所有情况然后比较出最大值，时间复杂度$O(n^2)$
```
#include<bits/stdc++.h>
using namespace std;
int a[11];
int water(int *a,int first,int last)
{
    return min(a[first],a[last])*(-first+last);
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    for(int j=i+1;j<=n;j++)
    {
        ans=max(ans,water(a,i,j));
    }
    cout<<ans<<endl;
    system("pause");
    return 0;
}
```
***方法二：尺取法扫描***
对于一个木桶来说，决定其最大盛水量的往往是小的木桶板，而理想上扩大容量就需要将小的变成大的。
对于木桶，在两端设立两个指针first和last，计算$[first，last]$区间内木桶的容量，再将木板长度较小的指针向里移动，逐次比较直至指针撞在一起，结束比较并输出结果。
此方法采用线性扫描的方式，几何倍数的缩小时间复杂度至$O(n)$.
```
#include<bits/stdc++.h>
using namespace std;
int a[11];
int water(int *a,int first,int last)
{
    return min(a[first],a[last])*(-first+last);
}
int search(int *a,int first,int last)
{
    int maxn=-1;
    while(first!=last)
    {
        maxn=max(maxn,water(a,first,last));
        a[first]>=a[last]? last--:first++;
    }
    return maxn;
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    cout<<search(a,1,n)<<endl;
    system("pause");
    return 0;

}
```
# 2.2  区间和统计

## 题目信息
***题目描述：***
给定一个包含$n$个元素的数组,数组中元素$a_i$保证 $-1000 < ai < 1000$。在数组中,从$l$到$r(l <= r)$的所有数叫做数组的一个$[l, r]$子区间,你需要求出,所有子区间中,和为$k$的区间一共有多少个。
***输入***
第一行包含一个整数$T$表示样例个数。
对于每一个样例,第一行输入两个数字,$n$,$ p$,其中$n$表示数组的长度, $p$代表区间和。
第二行包含$n$个数字表示数组的元素。
***输出***
对于每一个样例,输出一个数字表示和为$p$的子区间个数。
***样例输入***
```
1
5 8
4 4 4 4 4
```
***样例输出***
```
4
```
***数据范围***
所有的$a_i$均为整数。
保证 $n<=1000$
## 题目分析
***方法：数组前缀和***
和为$k$的子区间的个数，如果采用暴力必定超时$O(n^3)$，此时数组前缀和将大幅度降低算法的时间复杂度。
前缀和的精髓在于，将双端点不确定的闭区间$[l,r]$转化成了单端点不确定的两个区间$(0,l-1]$和$(l-1,r]$,这样就可以通过$O(1)$的时间复杂度来得到某个区间的子段和。
```
#include <bits/stdc++.h>
using namespace std;
int a[1001];
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin>>n;
        int k;
        cin>>k;
        int ans=0;
        for (int i = 1; i <= n; i++)
        {
            cin>>a[i];
            a[i]+=a[i-1];
        }
        for(int i=0;i<=n;i++)
        for(int j=i+1;j<=n;j++)
        if(a[j]-a[i]==k)ans++;
        cout<<ans<<endl;

    }
    system("pause");
    return 0;
}
```
# 2.3 子矩阵求和

## 题目信息
***题目描述：***
给定一个M行N列的矩阵，要求你求得子矩阵$(x1, y1)$, $(x2, y2)$的内所有元素的和。其中$(x1, y1)$和$(x2, y2)$是子矩阵的两个顶点。
***输入***
第一行输入包括三个数字$M N Q$。
接下来$M$行每行$N$个整数，表示需要处理的矩阵。
接下来$Q$行每行四个整数，表示子矩阵的方位。
***输出***
对于每一次询问，输出子矩阵内所有元素的和。
***样例输入***
```
4 3 2
1 2 3
4 5 6
7 8 9
10 11 12
0 0 3 2
0 0 1 1
```
***样例输出***
```
78
12
```
***数据范围***
$1 <= M,N <= 1000,Q <= 1000$
## 题目分析
***方法：二维数组前缀和***
原理同上，公式有所变化。
设二元函数$S(x,y)$表示从$a_{11}$元素到$a_{xy}$元素的全部元素和，则有：

$S(x_2,y_2)=a_{x_2y_2}+S(x_2-1,y_2)+S(x_2,y_2-1)-S(x_2-1,y_2-1) , x_2>x_1,y_2>y_1$

对于矩阵
$$A=\begin{bmatrix}
a_{x_1y_1} & a_{x_1y_1+1} & \cdots & a_{x_1y_2} \\
a_{x_1+1y_1}& a_{x_1+1y_1+1}& \cdots & a_{x_1+1y_2} \\
\vdots & \vdots &  \ddots & \vdots  \\
a_{x_2+1y_1}& a_{x_2y_1+1}& \cdots & a_{x_2y_2} \\
\end{bmatrix}$$
其元素和可以表示为
$\lambda(A)=S(x_2,y_2)-S(x_1-1,y_2)-S(x_2,y_1-1)+S(x_1,y_1)$

***注意：对于此题，$a_{11}$元素的对应坐标为$a_{00}$.而且，$x_1$和$x_2$大小要排对***
```
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull a[1001][1001];
int main()
{
    ull m,n,q;
    cin>>m>>n>>q;
    for(ull i=1;i<=m;i++)
        for(ull j=1;j<=n;j++) 
            {
                cin>>a[i][j];
                a[i][j]+=(a[i-1][j]+a[i][j-1]-a[i-1][j-1]);
            }
    while(q--)
    {
        ull x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
       if(x1>x2)swap(x1,x2);//
       if(y1>y2)swap(y1,y2);//
        cout<<a[x2+1][y2+1]+a[x1][y1]-a[x1][y2+1]-a[x2+1][y1]<<endl;

    }
    system("pause");
    return 0;
}
```
# 2.4 选择排序

## 题目信息
***题目描述：***
给你一个序列，按照从小到大的顺序重新排列，要求使用选择排序
***输入***
第一行是一个正整数$m$，代表测试样例的个数
对于每组测试样例，输入一行数字，第一个数字$m$，代表这组样例中数字的个数，接下来的$m$个数字代表所给序列
***输出***
对于每组输出样例，输出一行，输出按照从小到大顺序排列的结果
***样例输入***
```
3
2
2 1
5
9 5 1 4 3
6
2 3 8 1 5 6
```
***样例输出***
```
1 2
1 3 4 5 9
1 2 3 5 6 8
```
***数据范围***
正常范围之内

## 题目分析
虽然说本题目是标定了为选择排序，但在此处将系统的罗列最常见的十大种排序算法以及相应的细节分析。
***方法一：冒泡排序***

**平均时间复杂度：$O(n^2)$**
**最佳时间复杂度：$O(n)$**
**最坏时间复杂度：$O(n^2)$**
**空间复杂度：$O(1)$**
**稳定性：稳定**

冒泡排序，不多解释
```
void bubbles(int *a,int n)//从小到大
{
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n-i;j++)
        {
            if(a[j]>a[j+1])swap(a[j],a[j+1]);
        }
    }
}
```
***方法二：选择排序***

**平均时间复杂度：$O(n^2)$**
**最佳时间复杂度：$O(n^2)$**
**最坏时间复杂度：$O(n^2)$**
**空间复杂度：$O(1)$**
**稳定性：不稳定**

选择排序，即从左到右，设定指针$i$指向目标基准$a[i]$，遍历$i$后面的所有元素，如果有比基准值小的则更新基准值。遍历结束后，将更新完的基准值$a[j]$和$a[i]$互换位置。

<img src="2-2.gif" alt="2-2" style="zoom:80%;" />

```
void selectsort(int *a, int n)
{
    int min;
    for (int i = 1; i <= n; i++)
    {
        min = i;
        for (int j=i+1;j<=n;j++)
        {
            if(a[min]>a[j])min=j;
        }
        if(min!=i)swap(a[min],a[i]);
    }
}
```

