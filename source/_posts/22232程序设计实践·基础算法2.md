---
title: 22232程序设计实践·基础算法2
tags:
  - 程序设计
  - C++
  - 算法自学
categories:
  - 笔记
abbrlink: 2a94924b
date: 2023-03-06 09:57:46
---

这是本系列的第二篇文章，旨在记录我学习C++历程中所有的感想和感悟。
***本片摘要：***
<!--more-->

# 2.

## 题目信息
***题目描述：***

***输入***

***输出***

***样例输入***

***样例输出***

***数据范围***

## 题目分析

# 2.1 最多水容器
## 题目信息
***题目描述：***
给定一个数组, 每个数值代表柱子的高度, 那么求出这些柱子最多可以装多少水. 水的体积由较短的长度乘以两个柱子的距离.
{% asset_img 2-1.png 图1 %}
上面的图的输入为 [1,8,6,2,5,4,8,3,7]. 蓝色区域最可以装水为49.
***输入***
第一行输入一个数字N表示容器个数。第二行输入N个使用空格间隔的证书，表示容器高度。
***输出***
输出一个数字表示最多装水量。
***样例输入***
9
1 8 6 2 5 4 8 3 7
***样例输出***
49
***数据范围***
2 <= N <= 10
## 题目分析
***方法一：暴力模拟***
直接$C_{n}^{2}$暴力选取所有情况然后比较出最大值，时间复杂度$O(n^2)$
```
#include<bits/stdc++.h>
using namespace std;
int a[11];
int water(int *a,int first,int last)
{
    return min(a[first],a[last])*(-first+last);
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    for(int j=i+1;j<=n;j++)
    {
        ans=max(ans,water(a,i,j));
    }
    cout<<ans<<endl;
    system("pause");
    return 0;
}
```
***方法二：尺取法扫描***
对于一个木桶来说，决定其最大盛水量的往往是小的木桶板，而理想上扩大容量就需要将小的变成大的。
对于木桶，在两端设立两个指针first和last，计算$[first，last]$区间内木桶的容量，再将木板长度较小的指针向里移动，逐次比较直至指针撞在一起，结束比较并输出结果。
此方法采用线性扫描的方式，几何倍数的缩小时间复杂度至$O(n)$.
```
#include<bits/stdc++.h>
using namespace std;
int a[11];
int water(int *a,int first,int last)
{
    return min(a[first],a[last])*(-first+last);
}
int search(int *a,int first,int last)
{
    int maxn=-1;
    while(first!=last)
    {
        maxn=max(maxn,water(a,first,last));
        a[first]>=a[last]? last--:first++;
    }
    return maxn;
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    cout<<search(a,1,n)<<endl;
    system("pause");
    return 0;

}
```
# 2.2  区间和统计

## 题目信息
***题目描述：***
给定一个包含$n$个元素的数组,数组中元素$a_i$保证 $-1000 < ai < 1000$。在数组中,从$l$到$r(l <= r)$的所有数叫做数组的一个$[l, r]$子区间,你需要求出,所有子区间中,和为$k$的区间一共有多少个。
***输入***
第一行包含一个整数$T$表示样例个数。
对于每一个样例,第一行输入两个数字,$n$,$ p$,其中$n$表示数组的长度, $p$代表区间和。
第二行包含$n$个数字表示数组的元素。
***输出***
对于每一个样例,输出一个数字表示和为$p$的子区间个数。
***样例输入***
1
5 8
4 4 4 4 4
***样例输出***
4
***数据范围***
所有的$a_i$均为整数。
保证 $n<=1000$
## 题目分析
***方法：数组前缀和***
和为$k$的子区间的个数，如果采用暴力必定超时$O(n^3)$，此时数组前缀和将大幅度降低算法的时间复杂度。
前缀和的精髓在于，将双端点不确定的闭区间$[l,r]$转化成了单端点不确定的两个区间$(0,l-1]$和$(l-1,r]$,这样就可以通过$O(1)$的时间复杂度来得到某个区间的子段和。
```
#include <bits/stdc++.h>
using namespace std;
int a[1001];
int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin>>n;
        int k;
        cin>>k;
        int ans=0;
        for (int i = 1; i <= n; i++)
        {
            cin>>a[i];
            a[i]+=a[i-1];
        }
        for(int i=0;i<=n;i++)
        for(int j=i+1;j<=n;j++)
        if(a[j]-a[i]==k)ans++;
        cout<<ans<<endl;

    }
    system("pause");
    return 0;
}
```
# 2.3 子矩阵求和

## 题目信息
***题目描述：***
给定一个M行N列的矩阵，要求你求得子矩阵$(x1, y1)$, $(x2, y2)$的内所有元素的和。其中$(x1, y1)$和$(x2, y2)$是子矩阵的两个顶点。
***输入***
第一行输入包括三个数字$M N Q$。
接下来$M$行每行$N$个整数，表示需要处理的矩阵。
接下来$Q$行每行四个整数，表示子矩阵的方位。
***输出***
对于每一次询问，输出子矩阵内所有元素的和。
***样例输入***
4 3 2
1 2 3
4 5 6
7 8 9
10 11 12
0 0 3 2
0 0 1 1
***样例输出***
78
12
***数据范围***
$1 <= M,N <= 1000,Q <= 1000$
## 题目分析
***方法：二维数组前缀和***
原理同上，公式有所变化。
设二元函数$S(x,y)$表示从$a_{11}$元素到$a_{xy}$元素的全部元素和，则有：

$S(x_2,y_2)=a_{x_2y_2}+S(x_2-1,y_2)+S(x_2,y_2-1)-S(x_2-1,y_2-1) , x_2>x_1,y_2>y_1$

对于矩阵
$$A=\begin{bmatrix}
a_{x_1y_1} & a_{x_1y_1+1} & \cdots & a_{x_1y_2}\\
a_{x_1+1y_1}& a_{x_1+1y_1+1}& \cdots & a_{x_1+1y_2}\\
\vdots & \vdots &  \ddots & \vdots \\
a_{x_2+1y_1}& a_{x_2y_1+1}& \cdots & a_{x_2y_2}
\end{bmatrix}$$
其元素和可以表示为
$\lambda(A)=S(x_2,y_2)-S(x_1-1,y_2)-S(x_2,y_1-1)+S(x_1,y_1)$

***注意：对于此题，$a_{11}$元素的对应坐标为$a_{00}$.而且，$x_1$和$x_2$大小要排对***
```
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull a[1001][1001];
int main()
{
    ull m,n,q;
    cin>>m>>n>>q;
    for(ull i=1;i<=m;i++)
        for(ull j=1;j<=n;j++) 
            {
                cin>>a[i][j];
                a[i][j]+=(a[i-1][j]+a[i][j-1]-a[i-1][j-1]);
            }
    while(q--)
    {
        ull x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
       if(x1>x2)swap(x1,x2);//
       if(y1>y2)swap(y1,y2);//
        cout<<a[x2+1][y2+1]+a[x1][y1]-a[x1][y2+1]-a[x2+1][y1]<<endl;

    }
    system("pause");
    return 0;
}
```
